<!-- templates/index.html -->
{% extends "base.html" %}

{% block title %}Gemini AI Chat{% endblock %}

{% block content %}
<div class="chat-container">
    <div id="conversationHistory">
        <!-- Example of how a message will look -->
        <div class="message model">
            Hello! How can I help you today?
        </div>
    </div>

    <div id="loading" class="spinner-wrapper hidden">
        <div class="spinner"></div>
    </div>

    <div id="errorContainer" class="hidden">
        <p id="errorMessage"></p>
    </div>

    <div class="chat-input-area">
        <textarea id="promptInput" placeholder="Message Gemini..." rows="1"></textarea>
        <button id="generateButton" title="Send Message">
            <!-- SVG Icon for Send -->
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path>
            </svg>
        </button>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const promptInput = document.getElementById('promptInput');
        const generateButton = document.getElementById('generateButton');
        const conversationHistoryDiv = document.getElementById('conversationHistory');
        const loadingDiv = document.getElementById('loading');
        const errorContainer = document.getElementById('errorContainer');
        const errorMessage = document.getElementById('errorMessage');

        // This JS automatically handles resizing the textarea as you type
        promptInput.addEventListener('input', () => {
            promptInput.style.height = 'auto';
            promptInput.style.height = (promptInput.scrollHeight) + 'px';
        });

        // Your existing JavaScript for chat functionality goes here.
        // It does not need to be changed.
        // I've copied it below for completeness.

        let conversation = [];

        // Function to display a message, now with better HTML parsing
        function displayMessage(role, text) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', role);

            // A more robust way to handle markdown-like text from Gemini
            // This is a simplified parser
            let formattedText = text
                .replace(/</g, "<").replace(/>/g, ">") // Sanitize HTML tags
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italics
                .replace(/`([^`]+)`/g, '<code>$1</code>') // Inline code
                .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>') // Code blocks
                .replace(/\n/g, '<br>'); // Newlines
            //below line removed as 'You:' and 'Gemini:' is not required
            //messageDiv.innerHTML = `<strong>${role === 'user' ? 'You' : 'Gemini'}:</strong><br>${formattedText}`;
            messageDiv.innerHTML = formattedText;
            conversationHistoryDiv.appendChild(messageDiv);
            conversationHistoryDiv.scrollTop = conversationHistoryDiv.scrollHeight;
        }

async function handleSend() {
    const prompt = promptInput.value.trim();
    if (!prompt) return;

    // Display the user's message immediately for a good UX.
    // The server will handle masking.
    displayMessage('user', prompt);

    const currentHistory = conversation; // Keep a copy of the history to send

    // Clear the input and disable the form
    promptInput.value = '';
    promptInput.style.height = 'auto';
    errorContainer.classList.add('hidden');
    errorMessage.textContent = '';
    loadingDiv.classList.remove('hidden');
    generateButton.disabled = true;
    promptInput.disabled = true;

    try {
        const response = await fetch('/generate_text', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            // Send the CURRENT prompt and the history BEFORE this prompt.
            // DO NOT add the new prompt to the history here.
            body: JSON.stringify({ prompt: prompt, history: currentHistory })
        });

        if (!response.ok) {
            // ... (your existing error handling) ...
        }

        const data = await response.json();
        
        // The server is the source of truth. It sends back the
        // AI's response AND the complete, correct new history.
        
        // First, remove the last user message we optimistically displayed
        conversationHistoryDiv.lastChild.remove();
        
        // Now, display the fully correct, masked user message from the server's history
        const lastUserMessage = data.history[data.history.length - 2];
        displayMessage(lastUserMessage.role, lastUserMessage.parts[0].text);

        // Then display the AI's response
        displayMessage('model', data.generated_text);
        
        // Finally, update the conversation state with the new, correct history from the server.
        conversation = data.history;

            } catch (error) {
                errorContainer.classList.remove('hidden');
                errorMessage.textContent = `Error: ${error.message}`;
                conversation.pop();
            } finally {
                loadingDiv.classList.add('hidden');
                generateButton.disabled = false;
                promptInput.disabled = false;
                promptInput.focus();
            }
        }
        
        generateButton.addEventListener('click', handleSend);
        promptInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSend();
            }
        });
    });
</script>
{% endblock %}